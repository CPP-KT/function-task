# std::function
Класс [`std::function`](https://en.cppreference.com/w/cpp/utility/functional/function) представляет собой оболочку для полиморфных функций. Экземпляры `std::function` могут хранить, копировать и вызывать любой копируемый [`Callable-объект`](https://en.cppreference.com/w/cpp/named_req/Callable) - функции (через указатели на них), лямбда-выражения, объекты `bind`, а также указатели на методы классов и указатели на члены данных.

`std::function` может не хранить внутри себя `callable-объект`. Тогда в случае вызова opeartor() должно быть выброшенно исключение `bad_function_call`

Также требуется small-object оптимизация на объект `callable`

# Идеи и подсказки для реализации `std::function`
1. Сделать шаблонный класс `<R, Args...>` дескриптора, который будет заниматься копией, мувом, разрушением и вызовом вашей функции. Сделать `static` функцию, которые будут выдавать вам экземпляры дескриптора для вашей функции (подумайте будет ли он шаблонным, и если да, то чем параметризуется)
2. Small-object оптимизация. В случае если у вас объект малых размеров, то нет смысла хранить указатель на него, лучше хранить его по месту. В данной практике это особо актуально ибо `Callable` объекты это легковесные объекты. Исключением будут являться например лямбда-функция с захватом переменных. Для ее реализации нужно в классе хранить буффер нужного размера и выравнивания (например [`std::aligned_storage
   `](https://en.cppreference.com/w/cpp/types/aligned_storage))
3. Пустой `std::function`. Чтобы не ифать везде можно сделать специальный "пустой" дескриптор
4. **Для простоты реализации небросающего move constructorа и move assigmentа  function, SOO можно поддерживать только для T с небросающим мувами**
