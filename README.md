# function
Класс [`function`](https://en.cppreference.com/w/cpp/utility/functional/function) представляет собой полиморфную оболочку для функций. Экземпляры `function` могут хранить любой копируемый объект типа Т, который (тип) обладает свойством [Callable](https://en.cppreference.com/w/cpp/named_req/Callable), и вызывать его. Тип Т удовлетворяет свойству `Callable`, если он: указатель на функцию, лямбда-выражение, экземпляр класса с перегруженным `operator()` и т.д. В дальнейшем для простоты будем говорить `callable-object`

По дефолту `function` не хранит внутри себя никакой `callable-object` (в дальнейшем будем называть такой `function` пустым). Тогда в случае вызова operator() должно быть выброшено исключение `bad_function_call`

# Требования
Small-object оптимизация на `callable-object`. **Для простоты реализации небросающего move constructor и move assigment  operator, SOO можно поддерживать только для T с небросающими мувами**

# Идеи и подсказки для реализации `function`
1. В классе нам нужно хранить всего два поля: сам объект и дескриптор к нему. Дескриптор это специальный класс, который будет помогать нам интерпретировать наш объект как объект типа T. Зачем он нам? Как минимум из-за type erasure до `R(Args...)` (так как у нас полиморфная обертка над функциями). Нам будет непонятно как с ним работать. Например, если изначально это был экземпляр класса с перегруженным operator(), то у него мог быть кастомный конструктор копирования. Для этого нужно сделать специальный класс (aka дескриптор) параметризуемый `<R, Args...>` , который будет заниматься копией, мувом, разрушением и вызовом вашей функции (все они будут принимать объект из `function`). Внутри класса можно сделать `static` функцию, которые будут выдавать вам экземпляры дескриптора для хранимой функции (подумайте будет ли он шаблонным, и если да, то чем параметризуется)
2. Small-object оптимизация (SOO) на `callable-object`. В случае если у вас объект малых размеров, то нет смысла хранить указатель на него, лучше хранить его по месту. В данной практике это особо актуально ибо `callable-object` в большинстве своем легковесны. Однако всегда так делать не получится, ибо например есть лямбда-функции с захватом переменных. Для реализации SOO нужно в классе хранить буфер нужного размера и выравнивания, в котором и будет базироваться один из двух вариантов размещения
3. Пустой `function`. Чтобы не ифать везде можно сделать специальный "пустой" дескриптор
